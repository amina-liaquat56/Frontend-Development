## Syllabus
- ReactJs features (VirtualDOM , ReConciliation)
- Local Environemnt Setup (Create-react-app , vite)
- JSX
- Class Components
- Functional Components
- React Object
- Fragment
- Component Styling
- Conditional rendering
- Lists & keys
- Props : de-structuring,requiring props, proptypes,default props
- State 
- Pure Component
- Memo Component
- HigherOrder Component
- Events : Synthetic Event
- Lifecycle Hooks
- Form
- Http - Axios
- Interceptors
- Routing
- REDUX  (State Management)
- Unit Testing (JEST)
- EsLint

## React Local Setup
1. download Nodejs and install
```
   https://nodejs.org/en/download/
```

2. check if nodejs is installed? (open cmd and run the below command)
```
   node -v 
```

3. check if NPM is installed? (NPM-Node Package Manager)
```
   npm -v    
```
```
   
```
4.  go to the folder where you want to create project(d:/sanjay/react)& run the below command	
	npx create-react-app project1 (npx-node package executer)
	
```
                 
```
5. go to the created project folder(project1) and start your React application
```
   cd project1
```
```
   npm start 
```
```
  
```
6. A new browser window will pop up with your newly created React App! 
```
   open a browser tab and type 'http://localhost:3000/' if browser doesn't open automatically.
```
```
   set PORT=3001 && npm start

React Project with Typescript
=============================
-Create React App supports TypeScript out of the box.
-To create a new project with TypeScript support, run the below command
 npx create-react-app my-app --template typescript
-To add TypeScript to an existing Create-React-App project, install the below things
 npm install --save typescript @types/node @types/react @types/react-dom @types/jest

 

create-react-app
================
-It is a React application boilerplate generator created by Facebook. 
-This CLI tool installs React,ReactDOM & other libraries required for a react project.
-It provides a development environment configured for ease-of-use with minimal setup.
-It creates a frontend build pipeline. Under the hood, it uses Babel and webpack.



NPX
===
-NPX : node package executer. 
-Its a Package runner/executer tool.
-It can execute any package that you want from the npm registry without even installing that package.
 ex: npx create-react-app my-app
 

React app with Vite
===================
-Vite.js is a build tool and development server that is designed to optimize the development experience for modern web applications.
-It includes built-in support for TypeScript, CSS preprocessors.


1. Create a vite project
	npm create vite@latest
		(OR)
	npm create vite@latest my-app -- --template react  
		(OR)
	npm create vite@latest my-app -- --template react-ts
	
2. Go to the crated Project, install , and serve the application
	cd my-app
	npm install
	npm run dev
   
```
```
 
What React is
=============
-React is a JavaScript library for building user interfaces.
-It is an open-source, component based library. 
-It is created & maintained by Facebook.
-React is used to build single page applications.
-React allows us to create reusable UI components.
-ReactJS uses virtual DOM based mechanism to fill in data (views) in HTML DOM. 




React is NOT a framework
========================
-React is a library and not a framework.
-The difference between a library and a framework is that a library only helps 
 us in one aspect whereas a framework helps us in many aspects. 
Let's take an example:
-React is a library because it only takes care of our UI.
-Angular, on the other hand, is a framework because it handles much more than the UI 
 (It handles Dependency Injection, CSS encapsulation, httpClient, Form validation, routing etc.)


	Framework										Library
=========================================================================
-group of libraries to make your work easier	-performs specific, well-defined operations
-provides ready to use tools,standards			-provides reusable functions for our code
 templates for fast application development
-Collection of libraries & APIs					-collection of helper functions,objects
-cann't be easily replaceable 					-can be easily replaceable by another
-angular,vue									-jQuery,ReactJs,lodash,moment
-Hospital with full of doctors					-A doctor who specializes in one 		



		React						Angular
===========================================================
1. Library-2013					 1. Framework-2009
2. Light-weight					 2. Heavy
3. JSX + Javascript				 3. HTML + Typescript
4. Uni-Directional				 4. Two-way
5. Virtual DOM					 5. Regular DOM
6. Axios 				 		 6. HttpClientModule 
7. No 		 					 7. Dependency Injection
8. No							 8. Form Validation
9. extra libraries needed		 9. No additional libraries
10. UI heavy					 10. Functionality Heavy




React Features
==============
-Light weight
-JSX
-Components  (easy to build, easy to extend,reusable,loosly coupled)
-Oneway Data Binding (watchers will not be there for bindings)
-Virtual DOM
-Easy to learn because of its simple Design
-Performance




DOM (Document Object Model)
==========================
-DOM is a tree-like structure representing the HTML of a web page
-Allows JavaScript to interact with and modify the page's content, structure, and style. 

Why virtual DOM?
===============
-Frequent DOM manipulations are expensive and performance heavy. 
-Every time the DOM changes, browser would need to recalculate the CSS, 
 run layout and repaint the web page.
-we need a way to minimize the time it takes to repaint the screen. 
 This is where the Virtual DOM comes in.
-React uses virtual DOM to enhance its performance.

 
What Virtual DOM is
===================
-A virtual DOM is a lightweight JavaScript object which is just a copy of the
 real DOM. 
-It is a node tree that lists the elements, their attributes and content as 
 Objects and their properties.
-Virtual DOM is a JavaScript object that mirrors the structure of the real DOM. 
-A virtual DOM is the DOM where a representation of the UI is kept in memory and synced with the DOM.
-React never reads from real DOM, only writes to it.

Virtual DOM Benefits:
=====================
Improved Performance: By reducing the number of direct DOM manipulations, the Virtual DOM significantly speeds up the update process. 
Optimized Updates: React intelligently determines the most efficient way to update the real DOM, minimizing costly reflows and repaints. 
Simplified Development: The Virtual DOM makes it easier to work with complex UIs by abstracting away the complexities of direct DOM manipulation. 

How does React Work? (Virtual DOM)
====================
Initial Render: When page loads, React creates a virtual DOM tree based on the initial JSX or HTML code.
State Changes: When the application's state changes (user input, data updates), Generates a new Virtual DOM tree based on updated data.
Diffing: React compares the new Virtual DOM with the previous Virtual DOM, It identifies what exactly changed 
Reconciliation: Based on diffing results, React calculates the minimal number of real DOM operations needed.
Real DOM Update: Only the necessary changes are applied to the real DOM, resulting faster updates. 

What is the difference between Shadow DOM and Virtual DOM?
==========================================================
-Shadow DOM is a browser technology for scoping variables and CSS in web components. 
-Virtual DOM is a concept implemented by React on top of browser APIs.

ReactDOM
========
-ReactDOM is the glue between React and the DOM.
-React creates a virtual representation of your User Interface (what we call a Virtual DOM) and then ReactDOM is the library that efficiently updates the DOM based on the Virtual DOM.
-The reason why the Virtual DOM exists is to figure out which parts of the UI need to be updated and then batch these changes together. 
-ReactDOM receives those instructions from React and then efficiently updates the DOM.

Web Browser Workflow
====================
Parsing HTML to construct DOM tree --> Render Tree construction --> Layout of the Render tree -->
 -->painting the render tree.

React Reconciliation 
====================
-Reconciliation is the process through which React updates the DOM.
 (syncing the Virtual DOM to the actual DOM)
-Reconciliation is the mechanism that tracks changes in a component state and renders 
 the updated state to the screen.
-It's a step that happens between the render() function being called and the displaying of elements on the screen. This entire process is called reconciliation.

Stack Reconciler < React-16
================
-Synchronous
-works like a stack
-cann't be interrupted

Fiber Reconciler
================
-Fiber is the new reconciliation engine or re-implementation of core algorithm in React v16.
-React Fiber reconciler makes it possible to divide the work into multiple units of work(incremental rendering).
-It sets the priority of each work, and makes it possible to pause, reuse, and abort the unit of work.
-Fiber is Asynchronous.
-reconciliation and rendering to the DOM weren't separated, and React couldn't pause 
 its traversal to jump to other renders in between. This often resulted in lagging inputs.

-Fiber allows the reconciliation and rendering to the DOM to be split into two separate phases:
 Phase 1: render(processing)
 -----------------------
 -React creates a list of all changes to be rendered in the UI 
 -Once the list is fully computed, React will schedule these changes to be executed in the next phase.
 -React doesn't make any actual changes in this phase.

 Phase 2: Commit
 ----------------
 -React tells the DOM to render the changes that was created in the previous phase.
 -the Reconciliation phase can be interrupted, the Commit phase cannot.

React Project - Folder Structure
================================
node_modules/	:  Provides npm packages to the entire workspace. Workspace-wide node_modules dependencies are visible to all projects.
public/ 		:  Only files inside the `public` folder can be referenced from the HTML
src/			:  Source files for the root-level application project.
.gitignore		:  Specifies intentionally untracked files that Git should ignore.
package.json	:  Configures npm package dependencies that are available to all projects in the workspace. 
package-lock.json : Provides version information for all packages installed into node_modules by the npm client. 
README.md		 : Introductory documentation for the application.

React Project Flow
==================
1. index.html  --> <div id="root"></div> (container to inject component)
2. index.js    --> root = ReactDOM.createRoot(document.getElementById('root'));
				   root.render(<App />)
                   where        what
3. App.js      -->  AppComponent Code

JSX
===
-JSX (JavaScript Syntax Extension)is a special syntax for React that makes it easier to represent the UI.
-JSX is used to describe the structure & content of a react component.
-JSX allows us to add the elements in DOM without using createElement() or appendChild() methods.
-JSX looks similar to HTML but it is not HTML.
-JSX code we write gets transformed into React.createElement().
-JSX is not part of browser. we need a tool(Babel)(a JavaScript compiler) 
 to transform it to valid JavaScript.
-JSX doesn't support void tags.
 <img>  		invalid
 <img></img>    valid
 <img /> 		valid
-Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.
-ex: class becomes className in JSX, and tabindex becomes tabIndex.

React Without JSX
=================
-Code written with JSX will be converted to use React.createElement(). 
-we don't have to use React,createElement() when we use JSX. 
Syntax : React.createElement(type,[props],[...children])
example: React.createElement(div , {name:'myDiv'},[<p> , <span>])
-The first argument is the type of element we're creating
-The second argument is props object.
-The last argument is the children of that element.

ex:  <div class='test'>This is a div</div>  
-Babel converts the above JSX line to the below code
return React.createElement("div", {
    class: "test"
  }, "This is a div");

React Element
=============
-A React element is a JavaScript object with specific properties and methods that React 
assigns and uses internally. 
-React elements are the instructions for how the browser DOM get created. 
-When we use ReactDOM library React elements are getting changed into DOM elements. 
-However, when we use React Native, React elements are getting changed into native UI elements of Android or iOS.
-We create React elements using a function called createElement(). 
-createElement() method is part of the Top-Level React API, and we use it to create React elements. 
-This method takes three parameters:
	a. The first argument defines type of element to create. (h1/p/div)
	b. The second argument defines properties or attributes of the element.
	c. The third argument represents the element's children, any nodes or simple text that are inserted between the opening and closing tag.
	
const hello = React.createElement(
	"H1",
	{id: "msg", className: "title"},
	"Hello React Element"
);	

-document.createElement() returns a DOM element (for example a div or an h1). 
 Whereas React.createElement() returns an object that represents the DOM element.

Module Systems
==============
1. CommonJS
   module.exports = {member1,member2};
   const member1 = require('Library/file name');
2. ECMASCRIPT
   export member1;
   export default member2;
   import DefaultMember , {Namedmember} from 'file'

imports & exports
=================
-Default import:
  import DefaultMember from 'src/my_lib';
-Named imports:
  import { name1, name2 } from 'src/my_lib';
-Combining a default import with named imports
  import DefaultMember, { name1, name2 } from 'src/my_lib';

Named Export vs Default Export
==============================
-Only one default export is allowed per file,where as multiple named exports are allowed per file.
-Named exports are useful to export several values. 
-A default export can be a function, a class, an object(cann't be variables). 
 This value is to be considered as the “main” exported value since it will be the simplest to import
-The name of imported module has to be the same as the name of the exported module for named exports.
-The naming of import is completely independent in default export and we can use any name we like.
ex: import MyReact, { MyComponent } from "react";
           correct    wrong-namedExport

The React object
================
-When we import React,we get a React object that contains methods and properties.
-React exposes its current version through the version property, here's how we can read that.
 import React from "react"
 console.log(React.version); //"16.9.0" / 18.2.0
 <h2>React Version is {React.version}</h2>
-in cmd run the below command 
 npm view react version

React Emmet (react snippets - plugin)
===========
https://marketplace.visualstudio.com/items?itemName=rodrigovallades.es7-react-js-snippets

IMR - import React from 'react';
IMRD - import ReactDOM from 'react-dom'
IMRC - import React, { Component } from 'react'
IMPT -	import PropTypes from 'prop-types'
RCC - React class component
RCE - React class Export component
RFC - React Functional Component
RFCE - React Functional Export Component
RMC - React Function Memo component
RCONST - constructor with super
RPC - React Class Pure Component
RPCE - React Class Pure Export Component
RAFC - React Arrow Function Component
RAFCE - React Arrow Function export Component
REN - render() { return( ) }
SST - this.setState({ })

extensions
==========
1. React Snippet
2. ESLint
3. prettier
4. code spell checker
5. gitlens
6. vscode-icons
7. Thunder Client

Browser extension
=================
json viewer




React Plugins
=============
1. React Developer Tools
2. React-sight
3. Redux DevTools
   window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()

React.StrictMode
================
-StrictMode is a tool for highlighting potential problems in a react application.
-It activates additional checks and warnings for its descendants(child elements).
-Strict mode checks are run in development mode only,they do not impact the production build.
-Strict Mode helps with the below things:
	Identifying components with unsafe lifecycles (componentWillMount)
	Warning about legacy string ref API usage
	Warning about deprecated findDOMNode() usage
	Detecting unexpected side effects
	Detecting legacy context API
-ex: import React, { StrictMode } from "react";
     <StrictMode>
		<App />
     </StrictMode>
Note: StrictMode renders components twice (on dev but not production) in order to
      detect any problems with our code and warn us about them.

Component
=========
-Components are the most basic UI building block of a React application.
-Each Component is responsible for outputting a small,reusable piece of HTML.  
-A Component Represents a part of the User Interface.
-Components are Re-Usable and can be nested inside other component.
-A React application contains a tree of components.
-React components let you split the UI into independent, reusable pieces, 
  and think about each piece in isolation. 


2 types Of Component
====================
1. Functional Component ( stateless/presentational/dumb)
2. Class Component ( statefull)

-The simplest way to define a component in React is to write a JavaScript function:
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

-we can also use the ES6 class syntax to write components
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

-A functional component is just a plain JavaScript function which accepts props 
 as an argument and returns a React element.
-Functional Components are faster and much simpler than Class Components.
-Functional components are very useful in React, especially when you want to isolate state management from the component. That’s why they are often called stateless components.
 
-React class components can be defined by extending React.Component or React.PureComponent.
-React component can be defined as an ES6 class that extends the base React.Component class.
-a React class component must define a render method that specifies how the component renders to the DOM. 
-The render method returns React nodes, which can be defined using JSX syntax as HTML-like tags
-React requires that the first letter of a component class be capitalized. 
  This is required because based on capitalization JSX can tell the difference between 
  an HTML tag and a component instance. If the first letter of a name is capitalized, 
  then JSX realizes it’s a component instance; if not, then it’s an HTML tag.

Functional Component 			Class Component
	---------------------			---------------
1. No 'this' keyword				1. More feature rich
2. solution without state			2. Maintain own private data- state
3. Mainly for UI 					3. Complex UI Logic
4. Stateless/dumb/Presentational    4. Provide Life cycle hooks

When to use a Class Component over a Function Component?
========================================================
-If the component needs state or lifecycle methods then use class component 
 otherwise use function component. 
-However, from React 16.8 with the addition of Hooks, we can use state , lifecycle methods and other features  that were only available in class component in function component also. 
-So, it is always recommended to use Function components, unless you need a React functionality whose Function component equivalent is not present yet, like Error Boundaries.

How to Use Bootstrap in a React application
===========================================
1. install bootstrap
   npm i bootstrap@3.3.7 (particular version)
          OR
   npm i bootstrap     (latest version)
   npm i bootstrap-icons 
   
	
2. use 'bootstrap.min.css' in index.js file
   import "bootstrap/dist/css/bootstrap.min.css";
   import "bootstrap/dist/js/bootstrap.bundle.min.js";
   import 'bootstrap-icons/font/bootstrap-icons.css';

How to Use Bootstrap in a React application using CDN Link
===========================================================
-Bootstrap can be used in a react application just by adding the below CDN link in 'index.html'
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">

How to use Bootstrap icons
==========================
<i className="bi-alarm"></i>
<i className="bi-airplane" style={{ fontSize: "2rem", color: "cornflowerblue" }}></i>

How to use React-icons
======================
1. install react-icons
   npm install react-icons
2. import react-icons in component
   import { FaEdit, FaTrash } from 'react-icons/fa';
   import { BsFillCalendarDateFill,BsFillClockFill } from 'react-icons/bs';
3. use the Icons
   <FaEdit /> 
   <FaTrash color='red' />

Fragments
==========
-While returning elements in JSX, we can only return 1 element at a time.
 That element can have children but we have to ensure that we are only returning 1 element at a time, or else we will get a syntax error. (ex: a function can return 1 value)
-Fragments are way to render multiple elements without using a wrapper element.
-Fragment acts as a wrapper without adding unnecessary divs to the DOM. 
-We can use it directly from the React import, or deconstruct it.
	  import React from 'react';
	  <React.Fragment>
        <div>I am an element!</div>
        <button>I am another element</button>
      </React.Fragment>
-// Deconstructed
	import { Fragment } from 'react';
	<Fragment>
        <div>I am an element!</div>
        <button>I am another element</button>
     </Fragment>
-React version 16.2 simplified this process further, allowing for empty JSX tags to be interpreted as Fragments
   <>
		<div>I am an element!</div>
		<button>I am another element</button>
   </>

Data Binding
============
-Binding/Displaying  the variable value in UI is called data binding.


Binding Type    | Description                 | React Example      
--------------- | --------------------------- | ------------------ 
One-way Binding | State → UI                  |  {value}         
Two-way Binding | State ↔ UI using `onChange` |  value + onChange


 

CSS in React
============
different ways to add CSS:
1. inline CSS
2. External CSS
3. global css(index.css)
4. CSS Modules
5. Conditional CSS 

CSS Modules
===========
-This approach is designed to fix the problem of the global scope in CSS.
-A CSS Module is a CSS file in which all class names are scoped locally by default.
-CSS Modules allow to use the same CSS class name in different files without worrying about naming clashes.
-CSS Modules allow the scoping of CSS by automatically creating a unique classname of the below format.
	ex: [filename]\_[classname]\_\_[hash]
-ClassNames are dynamically generated, unique, and mapped to the correct styles.
-When importing the CSS Module from a JS Module, it exports an object.
	import styles from './Button.module.css'; // Import css modules stylesheet as styles
	import './another-stylesheet.css'; // Import regular stylesheet
	<button className={styles.error}>Error Button</button>;
-it will only apply the classname from css module even if both files have same 'error' class;

Conditional Rendering
=====================
-It is a common use case to show or hide elements based on certain conditions.
-It allows us to render different elements or components based on a condition.
-use cases:
	Rendering external data from an API.
	Showing or hiding elements.
	Toggling application functionality.
	Implementing permission levels.
	Handling authentication and authorization.
-ways to implement conditional rendering:
	Using an if…else Statement
	Using a switch Statement
	Using Ternary Operators
	Using Logical && (Short Circuit Evaluation) 
	
	
Ternary-  		<div>{flag ? <h1>Helllloooooo</h1> : null}</div>
Short Circuit-  <div>{flag && <h1>Helllloooooo</h1>}</div>

List Items - Lists and Keys
===========================
-A 'key' is a special attribute which should be included while creating List Items.	
-There will be a warning message in the console if the key prop is not present on list items.
-'Key' gives the elements a stable unique Identity.	
-'Key' helps react to identify which items have changed,are added, or removed.	
-React relies on the key to identify items in the list.
 React uses a virtual DOM, and it only re-draws the components that changed since the last render.
-The first time a component like IdiomaticReactList is rendered, React will see that you want to render a bunch of items, and it will create DOM nodes for them.
-The next time that component renders, React will say, “I already have some list items on screen are these ones different?” It will avoid recreating DOM nodes if it can tell that the items are the same.

-Tip: Avoid using the index as key, if the list is filtered or sorted 
 it will cause the key value to change to the new index and React will consider 
 them different elements and repaint the whole list.

-Why map() is used to iterate array instead of forEach()
 JSX needs an array of items to render,forEach() does not return anything (i.e it returns undefined). map() returns an array.

Read data from a JSON file
==========================
1. create a JSON file (employees.json/products.json/countries.json)
   [ {},{},{} ]
2. import EmployeeArr from './employees.json'
3. use EmployeeArr(List data) in JSX
   {EmployeeArr.map((emp,ind)=>{
       return <option key={ind} value={emp} />
   })}
   


Read data from a Javascript file
================================
1. create a JSON file (employees.js/products.js/countries.js)
   const employees = [ {},{},{} ];
   export default employees;
2. import EmployeeArr from './employees.json'
3. use EmployeeArr(List data) in JSX
   {EmployeeArr.map((emp,ind)=>{
       return <option key={ind} value={emp} />
   })}

Assignment
==========
1. create products.json with list of products. 
   https://fakestoreapi.com/products
2. display the products in table & card



forceUpdate	
===========	
-Declaring class variables/function variables is always a bad idea.	
-can be used for the below 2 use cases:
	Setting and clearing timeouts	
	Storing frequently-referenced values	
		
-React components will only re-render when there are changes to props or state.	
-Updating the class/function variable does not trigger a re-render.	
-Its our responsibility of triggering the re-render when our class data changes.	
-Normally we should try to avoid all uses of forceUpdate() and only read from 
 this.props and this.state in render().
-In class components,this.forceUpdate() is used to force a re-render.
-In Functional components,there is no concept of force re-render.


props
=====
-Props are inputs to components.
-Props stand for properties and is a special keyword in React.
-Attributes on Components get converted into an object called Props.
-Helps to Pass custom data to a component.
-props are used to pass data and methods from a parent component to a child component.
-data with props are being passed in a uni-directional flow. (one way from parent to child).
-We can pass props to any component as we declare attributes for any HTML tag
 <ChildComponent someAttribute={value} anotherAttribute={value}/>
-React props passed with just their name have a value of true.
 <myComponent showTitle={true}> 
 <myComponent showTitle> 
-The props can be accessed as shown below
 this.props.propName; (Class Component)
 props.propName; (Functional Component)


1.They are immutable. data coming from the parent should not be changed by child components. we will get an error if you try to change their value.
2.data with props are being passed in a uni-directional flow. (one way from parent to child)

Props De-structuring
====================
-It’s a JavaScript feature that allows us to extract multiple pieces of data from an array or object and assign them to their own variables.
-Improves readability.
-we can get rid of props/this.props in front of each property. 

-props de-structuring in functional component
 export default function Greet({ name, msg }){}
-we de-structure props in the render() function.(class Component)
 ex: let { pId, name, price } = this.props.product;

PropTypes
=========
-React has some built-in typechecking abilities.
-To run typechecking on the props for a component,we can assign the special propTypes property.
-PropTypes exports a range of validators that can be used to make sure the data the component receive is valid.
-When an invalid value is provided for a prop, a warning will be shown in the browser console. 
-For performance reasons, propTypes is only checked in development mode.not in production.

1. import PropTypes from 'prop-types';  
2. ComponentName.propTypes = {	
		variableName: PropTypes.string	
	};	


  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,
  optionalElement: PropTypes.element,
  optionalEnum: PropTypes.oneOf(['News', 'Photos']),
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),

Requiring Props
===============
-If prop values are not passed to a certain component, no error will be thrown.
Instead, within the component that prop will have a value of 'undefined'.
-Apart from specifying the type of the prop that can be passed to the component, 
 we can also make sure the prop is always provided to the component by chaining 
 isRequired at the end of the prop validator.

Student.propTypes = {
  name: PropTypes.string.isRequired, // Required Prop
  age: PropTypes.number  // Optional Prop
}



Default props
=============
-defaultProps allows to set default value for props. 
-ex: 	
	Greet.defaultProps = {	
		msg: 'this is my default message'	
	}	
-Functional Component & destructuring
 export default function Greet({name , msg='good morning'}) {
 }

Props.children	
==============	
-props.children represents the content between the tags of a Component.
-props.children can be an array or a single item.
-props.children is available on every component.	
-<Welcome>Hello world!</Welcome>	
-The string Hello world! is available in props.children in the Welcome component.	
-class Welcome extends React.Component {	
  render() {	
    return <p>{this.props.children}</p>;	
  }	
}

Ensuring Single Child
=====================
-We can use PropTypes.element to enforce that only a single child can be passed 
 to a component as children.
-If we try to pass more than 1 child to the component, we will get an error.
Ex: 	
Greet.propTypes = {	
    children: PropTypes.element	
};

Prop Drilling
=============
-Prop drilling is the process in a React app where props are passed from one component to another by going through other parts that do not need the data, but only help in passing it through the intermediate components.
-The problem with this approach is that most of the components through which this data is passed have no actual need for this data. 
-They are simply used as mediums for transporting this data to its destination component.
-as the components are forced to take in unrelated data and pass it to the next component, until it reaches its destination. This can cause major issues with component reusability and app performance.
-This Problem Can be avoided by using concepts like 'Context API' & 'REDUX'

Limitations of Local Variables
==============================
No re-rendering : Changing a Local variable doesn't re-render, the component won't update to reflect the new value.
No Persistence : Local variable are re-created on each render, any changes made to them are lost after re-render

export default function StateDemo1() {
    let count = 0;
    const increment = ()=>{
        count++;
        console.log(count);
    }
    return <>
        <h2>State Demo 1</h2>
        <div>Count value is: {count}</div>
        <button onClick={increment}>Increment</button>
    </>
}

Why State variables
===================
Re-rendering : when state variable changes, React re-renders the component with new value
Persistence : states are persisted accross re-renders

States
======
-The State of a component is an object that holds some data that may change over the lifetime of the component.
-whenever the state object changes,react will re-render the component. 
-States are Mutable(can be changed), and states are local to the component, cann't be used by other components directly
-Keep the state minimal , avoid using state for static data. 

State in Class Component
========================
-class components have a state object , where all the state variables are declared. 
 To update state variables, setState() should be used;
-State object is usually initialized inside the constructor in class components.
-UI will not Re-render when we change state directly, setState() should be used.
  this.counter = this.counter + 1; // re-render won't happpen
  this.setState({counter:this.state.counter+1});  // re-render will happpen
-use setState() to change the state of react Component. 
 it ensures that render() gets called.
-If a piece of code needs to be executed only after the state has been updated, then 
 place that code in the callback function which is the second arguement to setState()
 Syntax: setState( StateObject, callbackFunction);
  ex:    setState( {} , ()=>{} );

Note:
-----
-setState() actions are asynchronous. setState() doesn’t immediately mutate this.state.
-React may group multiple setState() calls in to a single update for better performance
-when we want to update the state based on the previous State value,
 we need to pass a function as an arguement to setState() instead passing an object.
 ex:- this.setState({ value: this.state.value + 1 });   
      this.setState(prevState => ({ value: prevState.value + 1 })); 
 
























